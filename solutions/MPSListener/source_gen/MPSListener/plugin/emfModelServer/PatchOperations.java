package MPSListener.plugin.emfModelServer;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNode;
import MPSListener.plugin.emfModelServer.parsers.PatchParser;
import java.util.Map;
import java.util.List;
import jetbrains.mps.project.Project;
import MPSListener.plugin.listener.GlobalSModelListener;
import java.util.ArrayList;
import java.util.concurrent.ConcurrentHashMap;
import MPSListener.plugin.synchronise.ContentSynchroniser;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import MPSListener.plugin.dataClasses.emf.patches.Patch;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import MPSListener.plugin.synchronise.NodeFactory;
import java.util.LinkedHashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.jetbrains.mps.openapi.language.SReferenceLink;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import javax.swing.SwingUtilities;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class PatchOperations {
  private static final Logger LOG = LogManager.getLogger(PatchOperations.class);
  private SNode startingNode;
  private java.util.logging.Logger log;
  private static PatchOperations instance;
  private PatchParser patchParser;
  private Map<SNode, Integer> modelStructuralMap;
  private List<SNode> structuralLanguageConcepts;
  private Project project;
  private GlobalSModelListener myListener;
  private boolean ignorePatch;

  private PatchOperations() {
    this.log = java.util.logging.Logger.getLogger(PatchOperations.class.getSimpleName());
    this.patchParser = new PatchParser();
    this.myListener = GlobalSModelListener.getInstance();
    this.structuralLanguageConcepts = new ArrayList<>();
  }

  public static PatchOperations getInstance() {
    if (instance == null) {
      instance = new PatchOperations();
    }
    return instance;
  }

  public boolean setIgnorePatch(boolean isIgnore) {
    return ignorePatch = isIgnore;
  }

  public void start(SNode startingNode, Project project) {
    this.modelStructuralMap = new ConcurrentHashMap<SNode, Integer>();
    this.modelStructuralMap.putAll(ContentSynchroniser.getInstance().getStructuralMap());
    for (SNode currentConcept : ListSequence.fromList(ContentSynchroniser.getInstance().getStructuralLanguageConcepts())) {
      this.structuralLanguageConcepts.add(currentConcept);
    }
    this.startingNode = startingNode;
    this.project = project;
  }

  public void executePatch(final String serverPatchResponse) {
    // Temporary fix to avoid duplicate operations since server fix is not deployed
    if (ignorePatch) {
      LoggingRuntime.logMsgView(Level.INFO, "Ignoring patch request.", PatchOperations.class, null, null);
      ignorePatch = false;
      return;
    }
    final List<Patch> serverPatches = patchParser.getPatch(serverPatchResponse);
    serverPatches.forEach((final Patch patch) -> {
      runCommand("Executing patch: " + patch.getOp(), new Runnable() {
        @Override
        public void run() {
          myListener.switchOffListener();
          switch (patch.getOp()) {
            case "replace":
              replace(patch.getPath(), ((String) patch.getValue()));
              break;
            case "remove":
              remove(patch.getPath());
              break;
            case "add":
              add(patch.getPath(), patch.getValue());
            case "move":
              move(patch.getPath(), patch.getValue());
            default:
              return;
          }
          myListener.switchOnListener();
        }
      });
    });

  }

  private void move(final String path, final Object value) {
  }

  private void add(final String path, final Object value) {
    final String[] pathSplit = path.split("/");
    if (pathSplit.length > 3) {
      final String toDecipher = pathSplit[3];
      SNode nodeToAddTo = getNode(path);
      if (isLinkDecleration(toDecipher, nodeToAddTo)) {
        handleAddReference(toDecipher, nodeToAddTo, value);
      } else if (isProperty(toDecipher, nodeToAddTo)) {
        handleAddProperty(toDecipher, nodeToAddTo, value);
      }
    } else {
      handleAddNode(path, value);
    }

  }
  private Boolean isLinkDecleration(String toDecipher, SNode node) {
    if (getReferenceLink(toDecipher, node) == null) {
      return false;
    }
    return true;
  }

  private void handleAddNode(String path, Object value) {
    final String[] pathSplit = path.split("/");
    final SContainmentLink containmentLink = NodeFactory.getSContainmentLink(startingNode, pathSplit[1]);
    final SNode child = new jetbrains.mps.smodel.SNode(ContentSynchroniser.getInstance().getConcept(containmentLink.getTargetConcept().getName()));
    final Integer index = (pathSplit[2].equals("-") ? getLastIndexByConcept(containmentLink.getTargetConcept().getName()) + 1 : Integer.valueOf(pathSplit[2]));

    SNode currNode = getNode(path);

    final LinkedHashMap<String, Object> valueMap = ((LinkedHashMap<String, Object>) value);
    valueMap.keySet().forEach((String currentField) -> {
      if (isLinkDecleration(currentField, child)) {
        handleAddReference(currentField, child, valueMap.get(currentField));
      } else if (isProperty(currentField, child)) {
        handleAddProperty(currentField, child, valueMap.get(currentField));
      }
    });
    SNodeOperations.insertNextSiblingChild(currNode, child);
    updateStructuralMap(child, index, Integer.MAX_VALUE, "+");

  }

  private void handleAddReference(String referenceName, SNode nodeToAddReference, final Object value) {
    LinkedHashMap<String, String> valueMap = ((LinkedHashMap<String, String>) value);
    SNode referenceNode = getReferenceNode(valueMap.get("$ref"));
    SLinkOperations.setTarget(nodeToAddReference, getReferenceLink(referenceName, nodeToAddReference), referenceNode);
  }

  private SReferenceLink getReferenceLink(String toFind, SNode node) {
    for (SReferenceLink currentReference : CollectionSequence.fromCollection(node.getConcept().getReferenceLinks())) {
      if (currentReference.getName().equals(toFind)) {
        return currentReference;
      }
    }
    return null;
  }

  private Boolean isProperty(String toDecipher, SNode node) {
    if (getProperty(node, toDecipher) == null) {
      return false;
    }
    return true;
  }

  private void handleAddProperty(String propertyName, SNode nodeToSetProperty, final Object value) {
    LoggingRuntime.logMsgView(Level.INFO, "Setting property", PatchOperations.class, null, null);
    String valueString = ((String) value);
    SPropertyOperations.set(nodeToSetProperty, getProperty(nodeToSetProperty, propertyName), valueString);
  }

  private void replace(String path, final String value) {
    if (path.contains("$ref")) {
      replaceReference(path, value);
    } else {
      replaceProperty(path, value);
    }
  }

  private void replaceProperty(final String path, final String value) {
    final SNode element = getNode(path);
    // Warning: Obtaining property like below might produce errors for nodes which have a child.
    String property = path.split("/")[3];
    SPropertyOperations.set(element, getProperty(element, property), value);
  }

  private void replaceReference(String path, final String value) {
    final SNode element = getNode(path);
    final String referenceLinkName = path.split("/")[3];
    String[] refPathArray = value.split("//@");
    final String[] referenceLocationTuple = refPathArray[refPathArray.length - 1].split("\\.");

    if (!(value.contains("$command.exec.res#"))) {
      final SContainmentLink containmentLink = NodeFactory.getSContainmentLink(this.startingNode, referenceLocationTuple[0]);
      if (containmentLink != null) {
        this.modelStructuralMap.entrySet().forEach((final Map.Entry<SNode, Integer> currentSet) -> {
          LoggingRuntime.logMsgView(Level.INFO, "Current key: " + String.valueOf(currentSet.getKey().getConcept().getName()), PatchOperations.class, null, null);
          LoggingRuntime.logMsgView(Level.INFO, "Current value: " + String.valueOf(currentSet.getValue()), PatchOperations.class, null, null);
          if (currentSet.getKey().getConcept().getName().equals(containmentLink.getTargetConcept().getName()) && Integer.valueOf(referenceLocationTuple[1]).equals(currentSet.getValue())) {
            SLinkOperations.setTarget(element, NodeFactory.getSReferenceLink(element, referenceLinkName), currentSet.getKey());
            return;
          }
        });
      }
    } else {
      SLinkOperations.setTarget(element, NodeFactory.getSReferenceLink(element, referenceLinkName), null);
    }
  }

  private void remove(final String path) {
    final String[] pathSplit = path.split("/");
    final String toDecipher = pathSplit[3];
    final SNode toRemove = getNode(path);
    if (pathSplit.length > 3) {
      if (isLinkDecleration(toDecipher, toRemove)) {
        LoggingRuntime.logMsgView(Level.INFO, "Removing reference", PatchOperations.class, null, null);
        SLinkOperations.setTarget(getNode(path), getReferenceLink(toDecipher, toRemove), null);
      } else if (isProperty(toDecipher, toRemove)) {
        LoggingRuntime.logMsgView(Level.INFO, "Removing property", PatchOperations.class, null, null);
        SPropertyOperations.set(toRemove, getProperty(getNode(path), toDecipher), null);
      }
    } else {
      LoggingRuntime.logMsgView(Level.INFO, "Removing node...", PatchOperations.class, null, null);
      final Integer removedNodeIndex = (pathSplit[2].equals("-") ? getLastIndexByConcept(pathSplit[1]) : Integer.valueOf(pathSplit[2]));
      updateStructuralMap(toRemove, removedNodeIndex, Integer.MAX_VALUE, "-");
      startingNode.removeChild(toRemove);
    }
  }

  private SProperty getProperty(SNode node, final String propertyName) {
    final Wrappers._T<SProperty> property = new Wrappers._T<SProperty>(null);
    LoggingRuntime.logMsgView(Level.INFO, "Fetching property: " + propertyName, PatchOperations.class, null, null);
    node.getConcept().getProperties().forEach((SProperty currentProperty) -> {
      if (currentProperty.getName().equals(propertyName)) {
        if (currentProperty.getName().equals(propertyName)) {
          LoggingRuntime.logMsgView(Level.INFO, "Property found!", PatchOperations.class, null, null);
          property.value = currentProperty;
        } else {
          LoggingRuntime.logMsgView(Level.INFO, "Property not found!", PatchOperations.class, null, null);
        }
      }
    });
    return property.value;
  }

  private void runCommand(String commandName, final Runnable runnable) {
    LoggingRuntime.logMsgView(Level.INFO, "Running command: " + commandName, PatchOperations.class, null, null);

    if (SwingUtilities.isEventDispatchThread()) {
      project.getModelAccess().executeCommand(runnable);
    } else {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          @Override
          public void run() {
            project.getModelAccess().executeCommand(runnable);
          }
        });
      } catch (InterruptedException e) {
        LoggingRuntime.logMsgView(Level.INFO, e.getMessage(), PatchOperations.class, null, null);
      } catch (Exception e) {
        LoggingRuntime.logMsgView(Level.INFO, e.getMessage(), PatchOperations.class, null, null);
      }
    }
  }

  private SNode getNode(String path) {
    // Only applicable when parsing "path" parameter received in patch from server.
    String[] pathSplit = path.split("/");
    SContainmentLink containmentLink = NodeFactory.getSContainmentLink(this.startingNode, pathSplit[1]);
    Integer index;

    // Reason for if statement below is when there is only one element remaining, then it does not return any index.
    if (pathSplit.length == 2) {
      index = 0;
    } else if (pathSplit[2].equals("-")) {
      index = getLastIndexByConcept(containmentLink.getTargetConcept().getName());
    } else {
      index = Integer.valueOf(pathSplit[2]);
    }

    for (SNode node : SetSequence.fromSet(this.modelStructuralMap.keySet())) {
      if (containmentLink.getTargetConcept().getName().equals(node.getConcept().getName())) {

        if (this.modelStructuralMap.get(node) == index) {
          return node;
        }
      }
    }
    return null;
  }

  private SNode getReferenceNode(String path) {
    // Only applicable for "$ref" paramater received from the server.

    // Function kind of a duplicate, can improve by checking if are dealing with reference or path..
    String[] pathSplit = path.split("//@")[1].split("\\.");
    SContainmentLink containmentLink = NodeFactory.getSContainmentLink(this.startingNode, pathSplit[0]);
    Integer index = Integer.valueOf(pathSplit[1]);

    for (SNode node : SetSequence.fromSet(this.modelStructuralMap.keySet())) {
      if (containmentLink.getTargetConcept().getName().equals(node.getConcept().getName())) {
        if (this.modelStructuralMap.get(node) == index) {
          return node;
        }
      }
    }

    return null;
  }
  public Integer getLastIndexByConcept(final String conceptName) {
    final Wrappers._T<Integer> highestIndex = new Wrappers._T<Integer>(Integer.MIN_VALUE);
    this.modelStructuralMap.keySet().forEach((SNode currentNodeConcept) -> {
      if (currentNodeConcept.getConcept().getName().equals(conceptName)) {
        if (highestIndex.value < PatchOperations.this.modelStructuralMap.get(currentNodeConcept)) {
          highestIndex.value = PatchOperations.this.modelStructuralMap.get(currentNodeConcept);
        }
      }
    });
    return highestIndex.value;
  }

  private void incrementOrDecrementIndexesByOneByConcept(final String conceptName, final Integer start, final Integer stop, final String op) {
    this.modelStructuralMap.keySet().forEach((SNode currentNodeConcept) -> {
      if (currentNodeConcept.getConcept().getName().equals(conceptName)) {
        Integer currentIndex = PatchOperations.this.modelStructuralMap.get(currentNodeConcept);
        if (currentIndex > start && currentIndex < stop) {

          LoggingRuntime.logMsgView(Level.INFO, "Performing " + op, PatchOperations.class, null, null);
          if (op.equals("+")) {
            PatchOperations.this.modelStructuralMap.put(currentNodeConcept, PatchOperations.this.modelStructuralMap.get(currentNodeConcept) + 1);
          } else {
            PatchOperations.this.modelStructuralMap.put(currentNodeConcept, PatchOperations.this.modelStructuralMap.get(currentNodeConcept) - 1);
          }
        }
      }
    });
  }
  public void updateStructuralMap(SNode child, Integer conceptStartIndex, Integer conceptEndIndex, String op) {
    if (op.equals("+")) {
      incrementOrDecrementIndexesByOneByConcept(child.getConcept().getName(), conceptStartIndex - 1, Integer.MAX_VALUE, op);
      modelStructuralMap.put(child, conceptStartIndex);
    } else {
      modelStructuralMap.remove(child);
      incrementOrDecrementIndexesByOneByConcept(child.getConcept().getName(), conceptStartIndex, Integer.MAX_VALUE, op);
    }
  }

  public Integer getIndexRespectiveToConcept(SNode node) {
    return this.modelStructuralMap.get(node);
  }
}
