package MPSListener.plugin.emfModelServer;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import MPSListener.plugin.synchronise.Mapper;
import java.util.logging.Logger;
import MPSListener.plugin.emfModelServer.parsers.PatchParser;
import org.jetbrains.mps.openapi.module.SRepository;
import com.intellij.openapi.project.Project;
import java.util.List;
import MPSListener.plugin.dataClasses.emf.patches.Patch;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.model.SNodeAccessUtil;
import jetbrains.mps.nodeEditor.EditorComponent;
import jetbrains.mps.nodeEditor.NodeEditorComponent;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;

public class PatchOperations {
  private SNode startingNode;
  private Mapper mapper;
  private Logger log;
  private static PatchOperations instance;
  private PatchParser patchParser;
  private SRepository repo;
  private Project currentProject;

  private PatchOperations(SNode startingNode, String subsribedModel) {
    this.startingNode = startingNode;
    this.mapper = Mapper.getInstance(startingNode, subsribedModel);
    this.log = Logger.getLogger(PatchOperations.class.getSimpleName());
    this.patchParser = new PatchParser();
    this.repo = startingNode.getModel().getRepository();
  }

  public static PatchOperations getInstance(SNode startingNode, String subscribedModel) {
    if (instance == null) {
      instance = new PatchOperations(startingNode, subscribedModel);
    }
    return instance;
  }

  public void executePatch(String serverPatchResponse) {
    log.info("Executing patch...");
    List<Patch> serverPatches = patchParser.getPatch(serverPatchResponse);
    serverPatches.forEach((Patch patch) -> {
      switch (patch.getOp()) {
        case "replace":
          replace(patch.getPath(), patch.getValue().get());
      }

    });

  }

  private void replace(String path, final String value) {
    log.info("Executing replace...");
    final SNode element = this.mapper.getNode(path);
    String property = path.split("/")[3];
    final SProperty propertyToReplace = getProperty(element, property);
    if (element != null && propertyToReplace != null) {
      element.getModel().getRepository().getModelAccess().runWriteAction(() -> {
        SNodeAccessUtil.setPropertyValue(element, propertyToReplace, value);
        EditorComponent editorComponent = new NodeEditorComponent(element.getModel().getRepository());
        editorComponent.rebuildEditorContent();
        NodeEditorComponent nodeEditorComponent = new NodeEditorComponent(element.getModel().getRepository());
        nodeEditorComponent.rebuildEditorContent();
      });
    } else {
      log.warning("Element not found");
    }
  }

  private SProperty getProperty(final SNode node, final String propertyName) {
    final Wrappers._T<SProperty> property = new Wrappers._T<SProperty>(null);
    node.getModel().getRepository().getModelAccess().runReadAction(() -> {
      for (SProperty currentProperty : node.getProperties()) {
        if (currentProperty.getName().equals(propertyName)) {
          log.info("Property found");
          property.value = currentProperty;
        } else {
          PatchOperations.this.log.warning("Property not found");
        }
      }
    });
    return property.value;
  }


}
