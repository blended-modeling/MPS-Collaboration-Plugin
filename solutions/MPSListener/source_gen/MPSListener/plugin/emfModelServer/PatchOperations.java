package MPSListener.plugin.emfModelServer;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNode;
import MPSListener.plugin.emfModelServer.parsers.PatchParser;
import java.util.Map;
import jetbrains.mps.project.Project;
import MPSListener.plugin.listener.GlobalSModelListener;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import java.util.List;
import MPSListener.plugin.dataClasses.emf.patches.Patch;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import MPSListener.plugin.synchronise.NodeFactory;
import MPSListener.plugin.synchronise.ContentSynchroniser;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.LinkedHashMap;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import javax.swing.SwingUtilities;
import jetbrains.mps.internal.collections.runtime.SetSequence;

public class PatchOperations {
  private static final Logger LOG = LogManager.getLogger(PatchOperations.class);
  private SNode startingNode;
  private java.util.logging.Logger log;
  private static PatchOperations instance;
  private PatchParser patchParser;
  private Map<SNode, Integer> modelStructuralMap;
  private Project project;
  private GlobalSModelListener myListener;
  private boolean ignorePatch;

  private PatchOperations() {
    this.log = java.util.logging.Logger.getLogger(PatchOperations.class.getSimpleName());
    this.patchParser = new PatchParser();
    this.myListener = GlobalSModelListener.getInstance();
  }

  public static PatchOperations getInstance() {
    if (instance == null) {
      instance = new PatchOperations();
    }
    return instance;
  }

  public boolean setIgnorePatch(boolean isIgnore) {
    return ignorePatch = isIgnore;
  }

  public void start(Map<SNode, Integer> modelStructuralMap, SNode startingNode, Project project) {
    this.modelStructuralMap = new HashMap<SNode, Integer>(modelStructuralMap);
    this.startingNode = startingNode;
    this.project = project;
  }

  public void executePatch(final String serverPatchResponse) {
    // Temporary fix to avoid duplicate operations since server fix is not deployed
    if (ignorePatch) {
      LoggingRuntime.logMsgView(Level.INFO, "Ignoring patch request.", PatchOperations.class, null, null);
      ignorePatch = false;
      return;
    }
    List<Patch> serverPatches = patchParser.getPatch(serverPatchResponse);
    myListener.switchOffListener();
    serverPatches.forEach((Patch patch) -> {
      LoggingRuntime.logMsgView(Level.INFO, "Executing patch " + patch.getOp(), PatchOperations.class, null, null);
      switch (patch.getOp()) {
        case "replace":
          replace(patch.getPath(), ((String) patch.getValue()));
          break;
        case "remove":
          remove(patch.getPath());
          break;
        case "add":
          add(patch.getPath(), patch.getValue());
        default:
          return;
      }
    });
    myListener.switchOnListener();
  }

  private void add(final String path, final Object value) {
    final String[] pathSplit = path.split("/");
    final SContainmentLink containmentLink = NodeFactory.getSContainmentLink(startingNode, pathSplit[1]);
    final Integer index = (pathSplit[2].equals("-") ? getLastIndexByConcept(containmentLink.getTargetConcept().getName()) + 1 : Integer.valueOf(pathSplit[2]));

    runCommand("add", new Runnable() {
      @Override
      public void run() {
        final SNode child = new jetbrains.mps.smodel.SNode(ContentSynchroniser.getInstance().getConcept(containmentLink.getTargetConcept().getName()));
        final SNode currNode = getNode(path);
        if (pathSplit.length > 3) {
          child.getConcept().getProperties().forEach((SProperty currentProperty) -> {
            if (currentProperty.getName().equals(pathSplit[3])) {
              LoggingRuntime.logMsgView(Level.INFO, "Property found", PatchOperations.class, null, null);
              SPropertyOperations.set(currNode, currentProperty, value.toString());
            }
          });
        } else {
          final LinkedHashMap<String, String> valueMap = ((LinkedHashMap<String, String>) value);
          valueMap.keySet().forEach((final String currentValue) -> child.getConcept().getProperties().forEach((SProperty currentProperty) -> {
            if (currentProperty.getName().equals(currentValue)) {
              SPropertyOperations.set(child, currentProperty, valueMap.get(currentValue));
              LoggingRuntime.logMsgView(Level.INFO, "Value set for property", PatchOperations.class, null, null);

            }
          }));
          SNodeOperations.insertNextSiblingChild(currNode, child);
          updateStructuralMap(child, index, Integer.MAX_VALUE, "+");
        }
      }
    });
  }

  private void replace(String path, final String value) {
    if (path.contains("$ref")) {
      replaceReference(path, value);
    } else {
      replaceProperty(path, value);
    }
  }

  private void replaceProperty(String path, final String value) {
    final SNode element = getNode(path);
    // Warning: Obtaining property like below might produce errors for nodes which have a child.
    String property = path.split("/")[3];
    final SProperty propertyToReplace = getProperty(element, property);
    if (element != null && propertyToReplace != null) {
      runCommand("Replace property", new Runnable() {
        @Override
        public void run() {
          element.setProperty(propertyToReplace, value);
        }
      });
    } else {
      LoggingRuntime.logMsgView(Level.WARN, "Property not found for concept: " + element.getConcept().getName(), PatchOperations.class, null, null);
    }
  }

  private void replaceReference(String path, final String value) {
    final SNode element = getNode(path);
    LoggingRuntime.logMsgView(Level.INFO, "ref loc: " + this.modelStructuralMap.get(getNode(path)), PatchOperations.class, null, null);
    final String referenceLinkName = path.split("/")[3];
    String[] refPathArray = value.split("//@");
    final String[] referenceLocationTuple = refPathArray[refPathArray.length - 1].split("\\.");

    if (!(value.contains("$command.exec.res#"))) {
      final SContainmentLink containmentLink = NodeFactory.getSContainmentLink(this.startingNode, referenceLocationTuple[0]);
      if (containmentLink != null) {
        this.modelStructuralMap.keySet().forEach((final SNode currentNode) -> {
          if (currentNode.getConcept().getName().equals(containmentLink.getTargetConcept().getName()) && Integer.valueOf(referenceLocationTuple[1]).equals(PatchOperations.this.modelStructuralMap.get(currentNode))) {
            runCommand("replace reference with a new reference", new Runnable() {
              @Override
              public void run() {
                SLinkOperations.setTarget(element, NodeFactory.getSReferenceLink(element, referenceLinkName), currentNode);
              }
            });
          }
        });
      }
    } else {
      runCommand("replace reference with null", new Runnable() {
        @Override
        public void run() {
          SLinkOperations.setTarget(element, NodeFactory.getSReferenceLink(element, referenceLinkName), null);
        }
      });

    }
  }

  private void remove(final String path) {
    runCommand("Remove node", new Runnable() {
      @Override
      public void run() {
        final String[] pathSplit = path.split("/");
        final SNode toRemove = getNode(path);
        final Integer removedNodeIndex = (pathSplit[2].equals("-") ? getLastIndexByConcept(pathSplit[1]) : Integer.valueOf(pathSplit[2]));
        updateStructuralMap(toRemove, removedNodeIndex, Integer.MAX_VALUE, "-");
        startingNode.removeChild(toRemove);
      }
    });
  }


  private SProperty getProperty(final SNode node, final String propertyName) {
    final Wrappers._T<SProperty> property = new Wrappers._T<SProperty>(null);
    LoggingRuntime.logMsgView(Level.INFO, "Fetching property: " + propertyName, PatchOperations.class, null, null);
    this.project.getRepository().getModelAccess().runReadAction(() -> {
      for (SProperty currentProperty : node.getProperties()) {
        if (currentProperty.getName().equals(propertyName)) {
          LoggingRuntime.logMsgView(Level.INFO, "Property found!", PatchOperations.class, null, null);
          property.value = currentProperty;
        } else {
          LoggingRuntime.logMsgView(Level.INFO, "Property not found!", PatchOperations.class, null, null);
        }
      }
    });
    return property.value;
  }

  private void runCommand(String commandName, final Runnable runnable) {
    LoggingRuntime.logMsgView(Level.INFO, "Running command: " + commandName, PatchOperations.class, null, null);

    if (SwingUtilities.isEventDispatchThread()) {
      project.getModelAccess().executeCommand(runnable);
    } else {
      try {
        SwingUtilities.invokeAndWait(new Runnable() {
          @Override
          public void run() {
            project.getModelAccess().executeCommand(runnable);
          }
        });
      } catch (InterruptedException e) {
        LoggingRuntime.logMsgView(Level.INFO, e.getMessage(), PatchOperations.class, null, null);
      } catch (Exception e) {
        LoggingRuntime.logMsgView(Level.INFO, e.getMessage(), PatchOperations.class, null, null);
      }
    }
  }

  private SNode getNode(String path) {
    String[] pathSplit = path.split("/");
    SContainmentLink containmentLink = NodeFactory.getSContainmentLink(this.startingNode, pathSplit[1]);
    Integer index;

    // Reason for if statement below is when there is only one element remaining, then it does not return any index.
    if (pathSplit.length == 2) {
      index = 0;
    } else if (pathSplit[2].equals("-")) {
      index = getLastIndexByConcept(containmentLink.getTargetConcept().getName());
    } else {
      index = Integer.valueOf(pathSplit[2]);
    }

    for (SNode node : SetSequence.fromSet(this.modelStructuralMap.keySet())) {
      if (containmentLink.getTargetConcept().getName().equals(node.getConcept().getName())) {

        if (this.modelStructuralMap.get(node) == index) {
          LoggingRuntime.logMsgView(Level.INFO, "Found node!", PatchOperations.class, null, null);
          return node;
        }
      }
    }
    return null;
  }

  public Integer getLastIndexByConcept(final String conceptName) {
    final Wrappers._T<Integer> highestIndex = new Wrappers._T<Integer>(Integer.MIN_VALUE);
    this.modelStructuralMap.keySet().forEach((SNode currentNodeConcept) -> {
      if (currentNodeConcept.getConcept().getName().equals(conceptName)) {
        if (highestIndex.value < PatchOperations.this.modelStructuralMap.get(currentNodeConcept)) {
          highestIndex.value = PatchOperations.this.modelStructuralMap.get(currentNodeConcept);
        }
      }
    });
    return highestIndex.value;
  }

  private void incrementOrDecrementIndexesByOneByConcept(final String conceptName, final Integer start, final Integer stop, final String op) {
    this.modelStructuralMap.keySet().forEach((SNode currentNodeConcept) -> {
      if (currentNodeConcept.getConcept().getName().equals(conceptName)) {
        Integer currentIndex = PatchOperations.this.modelStructuralMap.get(currentNodeConcept);
        if (currentIndex > start && currentIndex < stop) {

          LoggingRuntime.logMsgView(Level.INFO, "Performing " + op, PatchOperations.class, null, null);
          if (op.equals("+")) {
            PatchOperations.this.modelStructuralMap.put(currentNodeConcept, PatchOperations.this.modelStructuralMap.get(currentNodeConcept) + 1);
          } else {
            PatchOperations.this.modelStructuralMap.put(currentNodeConcept, PatchOperations.this.modelStructuralMap.get(currentNodeConcept) - 1);
          }
        }
      }
    });
  }
  public void updateStructuralMap(SNode child, Integer conceptStartIndex, Integer conceptEndIndex, String op) {
    if (op.equals("+")) {
      incrementOrDecrementIndexesByOneByConcept(child.getConcept().getName(), conceptStartIndex - 1, Integer.MAX_VALUE, op);
      modelStructuralMap.put(child, conceptStartIndex);
    } else {
      modelStructuralMap.remove(child);
      incrementOrDecrementIndexesByOneByConcept(child.getConcept().getName(), conceptStartIndex, Integer.MAX_VALUE, op);
    }
  }

  public Integer getIndexRespectiveToConcept(SNode node) {
    return this.modelStructuralMap.get(node);
  }
}
