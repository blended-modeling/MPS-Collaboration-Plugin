package MPSListener.plugin.emfModelServer.parsers;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import MPSListener.plugin.dataClasses.emf.getModel.fileData;
import java.util.HashMap;
import java.util.List;
import java.util.ArrayList;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.log4j.Level;
import MPSListener.plugin.dataClasses.emf.getModel.nodeEMF;
import java.util.Collections;
import java.util.Iterator;
import org.jetbrains.mps.openapi.model.SNode;

public class Parser {
  private static final Logger LOG = LogManager.getLogger(Parser.class);
  public Parser() {
  }

  public static fileData parseFileData(String serverResponseModel) {
    HashMap<String, Object> fileMap = getFileMapping(serverResponseModel);
    List<List<Object>> allNodes = new ArrayList<>();
    allNodes.add(as_jpiiov_a0a0c0d(fileMap.get("input"), List.class));
    allNodes.add(as_jpiiov_a0a0d0d(fileMap.get("output"), List.class));
    allNodes.add(as_jpiiov_a0a0e0d(fileMap.get("states"), List.class));
    fileData fileData = new fileData(as_jpiiov_a0a0a5a3(fileMap.get("$type"), String.class), as_jpiiov_a1a0a5a3(fileMap.get("$id"), String.class), as_jpiiov_a2a0a5a3(fileMap.get("name"), String.class), getNodes(allNodes));
    return fileData;
  }

  private static HashMap<String, Object> getFileMapping(String serverResponseModel) {
    TypeReference<HashMap<String, Object>> modelDataReference = new TypeReference<HashMap<String, Object>>() {};
    HashMap<String, Object> baseMap = null;
    HashMap<String, Object> dataMap = null;
    try {
      ObjectMapper objectMapper = new ObjectMapper();
      baseMap = objectMapper.readValue(serverResponseModel, modelDataReference);
      dataMap = as_jpiiov_a0a2a3a5((baseMap.get("data")), HashMap.class);
    } catch (JsonProcessingException e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error(e.getMessage());
      }
    }
    return dataMap;
  }


  private static List<nodeEMF> getNodes(List<List<Object>> allNodesList) {
    List<nodeEMF> allNodes = new ArrayList<>();
    for (List<Object> allNodeLists : allNodesList) {
      for (Object node : allNodeLists) {
        allNodes.add(new nodeEMF(as_jpiiov_a0a0a0a0a0b0i(node, HashMap.class)));
      }
    }
    return Collections.unmodifiableList(allNodes);
  }


  public static boolean nameIsMatch(String fileName, Iterator<? extends SNode> childrenIterator) {
    while (childrenIterator.hasNext()) {
      SNode currentNode = childrenIterator.next();
      if (currentNode.getName().equals(fileName)) {
        return true;
      }
    }
    return false;
  }
  private static <T> T as_jpiiov_a0a0c0d(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_jpiiov_a0a0d0d(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_jpiiov_a0a0e0d(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_jpiiov_a0a0a5a3(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_jpiiov_a1a0a5a3(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_jpiiov_a2a0a5a3(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_jpiiov_a0a2a3a5(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_jpiiov_a0a0a0a0a0b0i(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
