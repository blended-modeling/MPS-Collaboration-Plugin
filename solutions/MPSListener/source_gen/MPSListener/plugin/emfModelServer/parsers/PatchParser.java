package MPSListener.plugin.emfModelServer.parsers;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import java.util.List;
import MPSListener.plugin.dataClasses.emf.patches.Patch;
import java.util.ArrayList;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;
import jetbrains.mps.internal.collections.runtime.Sequence;
import com.fasterxml.jackson.core.type.TypeReference;
import java.util.HashMap;
import com.fasterxml.jackson.databind.JsonMappingException;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import com.fasterxml.jackson.core.JsonProcessingException;
import java.util.LinkedHashMap;

public class PatchParser {
  private static final Logger LOG = LogManager.getLogger(PatchParser.class);

  public static List<Patch> getPatch(String serverPatchResponse) {
    List<Patch> patchesList = new ArrayList<>();
    ObjectMapper objectMapper = new ObjectMapper();

    try {
      JsonNode nodes = objectMapper.readTree(serverPatchResponse);
      for (JsonNode node : Sequence.fromIterable(nodes)) {
        patchesList.add(parseToPatch(objectMapper.readValue(node.toPrettyString(), new TypeReference<HashMap<String, Object>>() {})));
      }

    } catch (JsonMappingException e) {
      LoggingRuntime.logMsgView(Level.INFO, "jsonMappingException", PatchParser.class, null, null);
      System.out.println(e.getMessage());
    } catch (JsonProcessingException e) {
      System.out.println(e.getMessage());
    }
    return patchesList;
  }

  private static Patch parseToPatch(HashMap<String, Object> readValue) {
    if (readValue.get("value") instanceof String) {
      return new Patch<String>(((String) readValue.get("op")), ((String) readValue.get("path")), ((String) readValue.get("from")), ((String) readValue.get("value")));

    } else {
      return new Patch<LinkedHashMap<String, Object>>(((String) readValue.get("op")), ((String) readValue.get("path")), ((String) readValue.get("from")), ((LinkedHashMap<String, Object>) readValue.get("value")));
    }
  }
}
