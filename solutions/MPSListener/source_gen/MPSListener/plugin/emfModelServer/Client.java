package MPSListener.plugin.emfModelServer;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.eclipse.emfcloud.modelserver.client.ModelServerClient;
import java.net.MalformedURLException;
import org.eclipse.emfcloud.modelserver.client.EObjectSubscriptionListener;
import org.eclipse.emfcloud.modelserver.emf.common.codecs.JsonCodecV2;
import org.eclipse.emfcloud.modelserver.client.ModelServerNotification;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emfcloud.modelserver.jsonpatch.JsonPatch;
import org.eclipse.emfcloud.modelserver.command.CCommandExecutionResult;
import java.util.Optional;
import org.eclipse.emfcloud.modelserver.client.Response;
import org.springframework.http.HttpHeaders;
import org.springframework.web.client.RestTemplate;
import org.springframework.http.ResponseEntity;
import org.springframework.web.client.HttpServerErrorException;
import org.apache.log4j.Level;
import org.apache.http.client.utils.URIBuilder;
import java.net.URISyntaxException;

public class Client {
  private static final Logger LOG = LogManager.getLogger(Client.class);
  private ModelServerClient modelServerClient;
  private String webSocketAddress;
  private String subscribedModel;
  private String models;
  private java.util.logging.Logger log;
  public Client(String subscriptionID) {
    this.webSocketAddress = "http://localhost:8081/api/v2/";
    // TODO: fix subscribedmodel
    this.subscribedModel = "StateMachine.xmi";
    this.models = "models";
    this.log = java.util.logging.Logger.getLogger(Client.class.getName());
    log.info("Subscribed model: " + subscriptionID);
    try {
      this.modelServerClient = new ModelServerClient(this.webSocketAddress);
    } catch (MalformedURLException e) {
    }
  }

  public void start() {
    this.modelServerClient.subscribe(this.subscribedModel, new EObjectSubscriptionListener(new JsonCodecV2()) {

      @Override
      public void onNotification(ModelServerNotification notification) {
        log.info("Notificaiton recieved:" + notification.getData().get());
        super.onNotification(notification);
      }
      @Override
      public void onIncrementalUpdate(EObject incrementalUpdate) {
        log.info("Incremental update recieved in eobject");
      }
      @Override
      public void onIncrementalUpdate(JsonPatch patch) {
        log.info("Incremental update recieved: " + patch.toString());
      }
      @Override
      public void onIncrementalUpdate(CCommandExecutionResult commandExecutionResult) {
        log.info("Incremental update recieved in commandExecutionResult");

      }
      @Override
      public void onSuccess(Optional<String> message) {
        log.info("Success!" + message.get());
      }
      @Override
      public void onError(Optional<String> message) {
        super.onError(message);
      }
      @Override
      public void onDirtyChange(boolean isDirty) {
        super.onDirtyChange(isDirty);
      }
      @Override
      public void onFullUpdate(EObject fullUpdate) {
        log.info("Full update recieved:" + fullUpdate.toString());
      }
      @Override
      public void onUnknown(ModelServerNotification notification) {
        log.info("Unknown...." + notification.getData().get());
      }
      @Override
      public void onOpen(Response<String> response) {
        log.info("Connected!" + response.getMessage());
      }
      @Override
      public void onClosing(int code, String reason) {
        super.onClosing(code, reason);
      }
      @Override
      public void onClosed(int code, String reason) {
        super.onClosed(code, reason);
      }
      @Override
      public void onFailure(Throwable throwable, Response<String> response) {
        super.onFailure(throwable, response);
      }
      @Override
      public void onFailure(Throwable throwable) {
        super.onFailure(throwable);
      }
    });
  }

  public void stop() {
    this.modelServerClient.unsubscribe(this.subscribedModel);
  }

  public String getAllModels() {
    if (LOG.isInfoEnabled()) {
      LOG.info("Getting all models....");
    }
    HttpHeaders headers = new HttpHeaders();
    RestTemplate restTemplate = new RestTemplate();
    ResponseEntity responseEntity = null;
    try {
      responseEntity = restTemplate.getForEntity(this.webSocketAddress + this.models, String.class);
    } catch (HttpServerErrorException su) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Error getting all models");
      }
    }
    return responseEntity.getBody().toString();
  }

  public String getModel(String modelUri) {
    if (LOG.isInfoEnabled()) {
      LOG.info("Attempting to retrieve model:" + modelUri);
    }
    HttpHeaders headers = new HttpHeaders();
    RestTemplate restTemplate = new RestTemplate();
    ResponseEntity responseEntity = null;
    try {
      String queryAddress = new URIBuilder(this.webSocketAddress + this.models).addParameter("modeluri", modelUri).build().toString();
      responseEntity = restTemplate.getForEntity(queryAddress, String.class);
    } catch (URISyntaxException se) {
      if (LOG.isInfoEnabled()) {
        LOG.info(se.getMessage());
      }
    }
    return responseEntity.getBody().toString();
  }
}
