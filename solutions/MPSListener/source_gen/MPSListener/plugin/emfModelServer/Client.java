package MPSListener.plugin.emfModelServer;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.eclipse.emfcloud.modelserver.client.ModelServerClient;
import MPSListener.plugin.synchronise.validation.PerformEcoreValidation;
import MPSListener.plugin.synchronise.ContentSynchroniser;
import java.net.MalformedURLException;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import org.eclipse.emfcloud.modelserver.client.JsonToStringSubscriptionListener;
import org.eclipse.emfcloud.modelserver.client.ModelServerNotification;
import java.util.Optional;
import org.eclipse.emfcloud.modelserver.client.Response;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.client.HttpServerErrorException;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import org.apache.http.client.utils.URIBuilder;
import java.net.http.HttpResponse;
import javax.swing.JOptionPane;
import java.net.URISyntaxException;
import java.io.IOException;
import java.util.Map;

public class Client {
  private static final Logger LOG = LogManager.getLogger(Client.class);
  private ModelServerClient modelServerClient;
  private String webSocketAddress;
  private String subscribedModel;
  private String models;
  private java.util.logging.Logger log;
  private PatchOperations patchOpeartions;
  private static Client instance;
  private PerformEcoreValidation eCoreValidator;
  private ContentSynchroniser contentSynchroniser;

  private Client() {
    this.webSocketAddress = "http://localhost:8081/api/v2/";
    this.models = "models";
    this.log = java.util.logging.Logger.getLogger(Client.class.getName());
    try {
      this.modelServerClient = new ModelServerClient(this.webSocketAddress);
    } catch (MalformedURLException e) {
    }
    this.patchOpeartions = PatchOperations.getInstance();
  }

  public static Client getInstance() {
    if (instance == null) {
      instance = new Client();
    }
    return instance;
  }

  public void start(SNode selectedInstance, Project project) {
    // TODO: 
    // 1. Get statemachine.ecore by extracting it from eClass of the model
    // 2. Finalise mapper checks to ensure ecoreIsMatchLocally returns true
    // 3. Add logic to shut down plugin if issue occurs. 
    this.subscribedModel = selectedInstance.getName() + "." + selectedInstance.getConcept().getName().toLowerCase();
    subscribe();

    this.eCoreValidator = new PerformEcoreValidation(selectedInstance);

    this.eCoreValidator.ecoreIsMatchLocally(getModel("statemachine.ecore", "json"));
    this.contentSynchroniser = ContentSynchroniser.getInstance();
    this.contentSynchroniser.start(this.eCoreValidator.getEcoreToMPS(), selectedInstance);

    if (this.contentSynchroniser.synchroniseContent(getModel(subscribedModel, "xmi"))) {
      LoggingRuntime.logMsgView(Level.INFO, "Synchronisation successful", Client.class, null, null);
    } else {
      LoggingRuntime.logMsgView(Level.INFO, "Synchronisation unsuccessful!", Client.class, null, null);
    }

    this.patchOpeartions.start(selectedInstance, project);
    if (LOG.isInfoEnabled()) {
      LOG.info("Client started successfully..");
    }
    LoggingRuntime.logMsgView(Level.INFO, "Client started successfully..", Client.class, null, null);
  }

  public void stop() {
    this.modelServerClient.unsubscribe(this.subscribedModel);
    this.eCoreValidator.stop();
    this.contentSynchroniser.stop();
  }

  private void subscribe() {
    this.modelServerClient.subscribe(this.subscribedModel, new JsonToStringSubscriptionListener() {
      @Override
      public void onNotification(ModelServerNotification notification) {
        super.onNotification(notification);
      }
      @Override
      public void onSuccess(Optional<String> message) {
        log.info("Connected to the server succesfully");
        LoggingRuntime.logMsgView(Level.INFO, "Connected to the server successfully!", Client.class, null, null);

      }
      @Override
      public void onError(Optional<String> message) {
        super.onError(message);
      }
      @Override
      public void onDirtyChange(boolean isDirty) {
        super.onDirtyChange(isDirty);
      }
      @Override
      public void onFullUpdate(String fullUpdate) {
        super.onFullUpdate(fullUpdate);
      }
      @Override
      public void onIncrementalUpdate(String incrementalUpdate) {
        LoggingRuntime.logMsgView(Level.INFO, "Patch received: " + incrementalUpdate, Client.class, null, null);
        patchOpeartions.executePatch(incrementalUpdate);
      }
      @Override
      public void onUnknown(ModelServerNotification notification) {
        super.onUnknown(notification);
      }
      @Override
      public void onOpen(Response<String> response) {
        super.onOpen(response);
      }
      @Override
      public void onClosing(int code, String reason) {
        super.onClosing(code, reason);
        log.info("Connection closed!");
      }
      @Override
      public void onClosed(int code, String reason) {
        super.onClosed(code, reason);
      }
      @Override
      public void onFailure(Throwable throwable, Response<String> response) {
        super.onFailure(throwable, response);
      }
      @Override
      public void onFailure(Throwable throwable) {
        super.onFailure(throwable);
      }
    });
  }

  public String getAllModels() {
    String serverResponse = null;
    try {
      serverResponse = new RestTemplate().getForEntity(this.webSocketAddress + this.models, String.class).getBody().toString();
    } catch (HttpServerErrorException su) {
      if (LOG.isEnabledFor(Level.WARN)) {
        LOG.warn("Error getting all models");
      }
    }
    return serverResponse;
  }

  public String getModel(String modelUri, String format) {
    String serverResponse = null;
    try {
      HttpClient httpClient = HttpClient.newHttpClient();
      HttpRequest httpRequest = HttpRequest.newBuilder(new URIBuilder(this.webSocketAddress + this.models).addParameter("modeluri", modelUri).addParameter("format", format).build()).GET().build();

      HttpResponse<String> httpResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString());
      serverResponse = httpResponse.body();
      LoggingRuntime.logMsgView(Level.INFO, "Got " + serverResponse, Client.class, null, null);
      if (httpResponse.statusCode() == 404) {
        JOptionPane.showMessageDialog(null, "Model does not exist (by name) in server. Exiting application!");
        System.exit(2);
      }
    } catch (URISyntaxException se) {
    } catch (IOException e) {
      System.exit(2);

    } catch (InterruptedException e) {
      LoggingRuntime.logMsgView(Level.INFO, "Interrupted exception", Client.class, null, null);
    }

    return serverResponse;
  }

  public String patchModel(String modelUri, String patch) {
    LoggingRuntime.logMsgView(Level.INFO, "Sending patch: " + patch, Client.class, null, null);

    String serverResponse = null;
    try {
      HttpClient httpClient = HttpClient.newHttpClient();
      HttpRequest httpRequest = HttpRequest.newBuilder(new URIBuilder(this.webSocketAddress + this.models).addParameter("modeluri", modelUri).build()).method("PATCH", HttpRequest.BodyPublishers.ofString(patch)).header("Content-Type", "application/json").build();
      serverResponse = httpClient.send(httpRequest, HttpResponse.BodyHandlers.ofString()).body();
    } catch (URISyntaxException se) {
    } catch (IOException e) {
    } catch (InterruptedException e) {
    }
    return serverResponse;
  }

  public Map<SNode, Integer> getStructuralMapping() {
    return this.contentSynchroniser.getStructuralMap();
  }
}
