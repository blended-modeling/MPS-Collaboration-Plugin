package MPSListener.plugin.parsers.emf;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import MPSListener.plugin.emfModelServer.EmfClient;
import com.fasterxml.jackson.databind.ObjectMapper;
import MPSListener.plugin.dataClasses.emf.fileData;
import java.util.HashMap;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.apache.log4j.Level;
import java.util.List;
import MPSListener.plugin.dataClasses.emf.input;
import java.util.ArrayList;
import java.util.Collections;
import MPSListener.plugin.dataClasses.emf.output;
import MPSListener.plugin.dataClasses.emf.states;
import java.util.Iterator;
import org.jetbrains.mps.openapi.model.SNode;
import org.apache.log4j.BasicConfigurator;
import java.util.Map;
import MPSListener.plugin.synchronise.MPS_synchroniseWithEMF;

public class EMF_parser {
  private static final Logger LOG = LogManager.getLogger(EMF_parser.class);
  private EmfClient emfClient;
  private ObjectMapper objectMapper;
  private fileData fileData;
  public EMF_parser() {
    this.emfClient = EmfClient.getInstance();
    this.objectMapper = new ObjectMapper();
    this.fileData = null;
  }

  public HashMap<String, Object> getFileMapping(String fileName) {
    String modelDetails = emfClient.getModel(fileName);

    TypeReference<HashMap<String, Object>> modelDataReference = new TypeReference<HashMap<String, Object>>() {};
    HashMap<String, Object> baseMap = null;
    HashMap<String, Object> dataMap = null;
    try {
      baseMap = objectMapper.readValue(modelDetails, modelDataReference);
      dataMap = as_8lxi7k_a0a1a5a6((baseMap.get("data")), HashMap.class);
    } catch (JsonProcessingException e) {
      if (LOG.isEnabledFor(Level.ERROR)) {
        LOG.error(e.getMessage());
      }
    }
    return dataMap;
  }

  public fileData parseFileData(HashMap<String, Object> fileMap) {
    fileData fileData = new fileData(as_8lxi7k_a0a0a0a8(fileMap.get("$type"), String.class), as_8lxi7k_a1a0a0a8(fileMap.get("$id"), String.class), as_8lxi7k_a2a0a0a8(fileMap.get("name"), String.class), getInputs(as_8lxi7k_a0d0a0a0i(fileMap.get("input"), List.class)), getOutputs(as_8lxi7k_a0e0a0a0i(fileMap.get("output"), List.class)), getStates(as_8lxi7k_a0f0a0a0i(fileMap.get("states"), List.class)));
    return fileData;
  }

  public List<input> getInputs(List<Object> inputs) {
    List<input> extractedInputs = new ArrayList<input>();
    for (Object object : inputs) {
      extractedInputs.add(new input(as_8lxi7k_a0a0a0a0b0k(object, HashMap.class)));
    }
    return Collections.unmodifiableList(extractedInputs);
  }

  public List<output> getOutputs(List<Object> inputs) {
    List<output> extractedOutputs = new ArrayList<output>();
    for (Object object : inputs) {
      extractedOutputs.add(new output(as_8lxi7k_a0a0a0a0b0m(object, HashMap.class)));
    }
    return Collections.unmodifiableList(extractedOutputs);
  }

  public List<states> getStates(List<Object> inputs) {
    List<states> extractedStates = new ArrayList<states>();
    for (Object object : inputs) {
      extractedStates.add(new states(as_8lxi7k_a0a0a0a0b0o(object, HashMap.class)));
    }
    return Collections.unmodifiableList(extractedStates);
  }


  public boolean nameIsMatch(String fileName, Iterator<? extends SNode> childrenIterator) {
    while (childrenIterator.hasNext()) {
      SNode currentNode = childrenIterator.next();
      if (currentNode.getName().equals(fileName)) {
        return true;
      }
    }
    return false;
  }


  public static void main(String[] args) {
    BasicConfigurator.configure();
    EMF_parser emf_synchroniseModel = new EMF_parser();
    HashMap<String, Object> map = emf_synchroniseModel.getFileMapping("StateMachine.xmi");
    Iterator<Map.Entry<String, Object>> iterator = map.entrySet().iterator();
    while (iterator.hasNext()) {
      Map.Entry<String, Object> iteratorEntry = iterator.next();

      if (LOG.isInfoEnabled()) {
        LOG.info(iteratorEntry.getValue());
      }
    }
    fileData fileData = emf_synchroniseModel.parseFileData(map);
    List<input> list = emf_synchroniseModel.getInputs(as_8lxi7k_a0a0a6a02(map.get("input"), List.class));
    MPS_synchroniseWithEMF syncLocally = new MPS_synchroniseWithEMF(fileData);
    if (LOG.isInfoEnabled()) {
      LOG.info(syncLocally.syncLocally().getModelName());
    }
  }
  private static <T> T as_8lxi7k_a0a1a5a6(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a0a0a0a8(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a1a0a0a8(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a2a0a0a8(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a0d0a0a0i(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a0e0a0a0i(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a0f0a0a0i(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a0a0a0a0b0k(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a0a0a0a0b0m(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a0a0a0a0b0o(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
  private static <T> T as_8lxi7k_a0a0a6a02(Object o, Class<T> type) {
    return (type.isInstance(o) ? (T) o : null);
  }
}
