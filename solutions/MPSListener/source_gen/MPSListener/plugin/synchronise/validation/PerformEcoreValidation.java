package MPSListener.plugin.synchronise.validation;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import MPSListener.plugin.synchronise.MPS_LocalRepo;
import com.fasterxml.jackson.databind.ObjectMapper;
import MPSListener.plugin.dataClasses.emf.ecore.Ecore;
import java.util.Map;
import MPSListener.plugin.dataClasses.emf.ecore.EClassifier;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import com.fasterxml.jackson.databind.MapperFeature;
import java.util.HashMap;
import java.io.IOException;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.ArrayList;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import java.util.Set;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import MPSListener.plugin.dataClasses.emf.ecore.ESuperType;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import MPSListener.plugin.dataClasses.emf.ecore.EStructuralFeature;
import jetbrains.mps.lang.core.behavior.IDeprecatable__BehaviorDescriptor;
import java.util.Optional;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SEnumOperations;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class PerformEcoreValidation {
  private static final Logger LOG = LogManager.getLogger(PerformEcoreValidation.class);
  private MPS_LocalRepo mpsLocalRepo;
  private String model;
  private String module;
  private java.util.logging.Logger log;
  private ObjectMapper om;

  private Ecore parsedServerSideEcore;
  private Map<EClassifier, SNode> ecoreToMPS;
  private Map<String, String> emfToMpsConceptTerms;
  private Map<String, String> emfToMpsProperties;
  private List<SNode> structuralElements;
  private SNode selectedInstance;

  public PerformEcoreValidation(SNode selectedInstance) {
    this.mpsLocalRepo = MPS_LocalRepo.getInstance(selectedInstance);
    // hard coded the model to look for.
    this.module = "StateMachines";
    this.model = "structure";
    this.selectedInstance = selectedInstance;
    this.log = java.util.logging.Logger.getLogger(PerformEcoreValidation.class.getSimpleName());
    this.om = new ObjectMapper();
    om.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);
    this.ecoreToMPS = new HashMap<>();
    this.emfToMpsConceptTerms = new HashMap<>();
    this.emfToMpsProperties = new HashMap<>();
  }
  public boolean ecoreIsMatchLocally(String eCoreString) {
    try {
      this.parsedServerSideEcore = this.om.readValue(eCoreString, Ecore.class);
    } catch (IOException e) {
      log.info(e.getMessage());
    }
    populateEmfToMpsTerms();
    boolean isMatch = false;
    // At the moment, structure contains text and table nodes. We are interested in text only, however at the moment the list below contains both. 
    SModel structuralModel = this.mpsLocalRepo.findModel(this.module, this.model);
    this.structuralElements = SModelOperations.roots(structuralModel, null);
    ArrayList<EClassifier> eClassifiers = parsedServerSideEcore.getData().getEClassifiers();
    if (allElementsPresentByName(eClassifiers, structuralElements)) {
      LoggingRuntime.logMsgView(Level.INFO, "All elements present", PerformEcoreValidation.class, null, null);
      eClassifiers.forEach((EClassifier eClassifier) -> {
        {
          SNode structuralNode = PerformEcoreValidation.this.ecoreToMPS.get(eClassifier);
          if (isMatchSuperType(eClassifier, structuralNode)) {
            LoggingRuntime.logMsgView(Level.INFO, "super type same for " + SPropertyOperations.getString(structuralNode, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
            LoggingRuntime.logMsgView(Level.INFO, SPropertyOperations.getString(structuralNode, PROPS.name$MnvL) + " structural features = " + String.valueOf(isMatchStructuralFeatures(eClassifier, structuralNode)), PerformEcoreValidation.class, null, null);
          } else {
            LoggingRuntime.logMsgView(Level.INFO, "super type not same for " + SPropertyOperations.getString(structuralNode, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
          }
        }
      });
    } else {
      LoggingRuntime.logMsgView(Level.INFO, "Mismatched ecore, all elements not present by name..", PerformEcoreValidation.class, null, null);
    }
    if (LOG.isInfoEnabled()) {
      LOG.info("Validation complete");
    }
    return isMatch;
  }


  private boolean allElementsPresentByName(ArrayList<EClassifier> eClassifiers, List<SNode> structuralElements) {
    // This method ensures that all eClassifiers from the eCore file are present in the structure. This method does not ensure all mps structural nodes are present in the ecore file. However, that should be done.
    // TODO: Method seems fishy, might not be checking if all eClasses are present, double check
    final Set<SNode> allStructuralNodes = getAllConcepts(structuralElements);
    final Wrappers._boolean elementPresent = new Wrappers._boolean();
    eClassifiers.forEach((final EClassifier eClassifier) -> {
      {
        elementPresent.value = false;
        final String eClassNameToCompare = (PerformEcoreValidation.this.emfToMpsConceptTerms.containsKey(eClassifier.getName()) ? PerformEcoreValidation.this.emfToMpsConceptTerms.get(eClassifier.getName()) : eClassifier.getName());
        SetSequence.fromSet(allStructuralNodes).visitAll(new IVisitor<SNode>() {
          public void visit(SNode structuralNode) {
            if (eClassNameToCompare.equals(SPropertyOperations.getString(structuralNode, PROPS.name$MnvL))) {
              elementPresent.value = true;
              PerformEcoreValidation.this.ecoreToMPS.put(eClassifier, SNodeOperations.cast(structuralNode, CONCEPTS.AbstractConceptDeclaration$KA));
            }
          }
        });
        if (!(elementPresent.value)) {
          return;
        }
      }
    });
    return elementPresent.value;
  }

  private boolean isMatchSuperType(EClassifier eClassifier, SNode nodeToCompare) {
    boolean isMatch = false;
    // This if statement is a bit misleading, nonetheless it checks wether the given eClassifier and MPS node have no supertypes or or if they do, then they are the same.
    if (eClassifier.getESuperTypes() == null && ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getImmediateSuperconcepts_idhMuxyK2.invoke(nodeToCompare)).count() == 0) {
      return true;
    }
    try {

      for (ESuperType superConceptEcore : ListSequence.fromList(eClassifier.getESuperTypes())) {
        {
          // Some native terms of emf differ than that of mps, look at the populateEmfToMpsTerms for the current list. Since they can be different, I noted the ones I observed and replace eCoreSuperType with that of MPS.
          String eCoreSuperType = superConceptEcore.get$ref().split("//")[1];
          eCoreSuperType = ((this.emfToMpsConceptTerms.containsKey(eCoreSuperType)) ? this.emfToMpsConceptTerms.get(eCoreSuperType) : eCoreSuperType);
          for (SNode superType : ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getImmediateSuperconcepts_idhMuxyK2.invoke(nodeToCompare))) {
            if (SPropertyOperations.getString(superType, PROPS.name$MnvL).equals(eCoreSuperType)) {
              isMatch = true;
            }
          }
          if (!(isMatch)) {
            break;
          }
        }
      }
    } catch (NullPointerException e) {
      log.info(e.getMessage());
      LoggingRuntime.logMsgView(Level.INFO, "Mismatch super type for " + eClassifier.getName(), PerformEcoreValidation.class, null, null);
    }
    return isMatch;
  }

  private boolean isMatchStructuralFeatures(EClassifier eClassifier, SNode nodeToCompare) {
    // Also compares abstract if present
    LoggingRuntime.logMsgView(Level.INFO, "Aggergat declaration: ", PerformEcoreValidation.class, null, null);
    ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.linkDeclaration$YU1f)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode linkDeclaration) {
        LoggingRuntime.logMsgView(Level.INFO, SPropertyOperations.getString(linkDeclaration, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
      }
    });
    ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.propertyDeclaration$YUgg)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode it) {
        LoggingRuntime.logMsgView(Level.INFO, SPropertyOperations.getString(it, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
      }
    });
    LoggingRuntime.logMsgView(Level.INFO, "Property declaration size: " + ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.propertyDeclaration$YUgg)).count(), PerformEcoreValidation.class, null, null);
    final Wrappers._boolean isMatch = new Wrappers._boolean(false);
    Boolean isCorrectMulticiplicity = null;
    if (eClassifier.getEStructuralFeatures() == null && ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.propertyDeclaration$YUgg)).count() == 0 && ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.linkDeclaration$YU1f)).count() == 0) {
      LoggingRuntime.logMsgView(Level.INFO, "Empty structure features detected for " + SPropertyOperations.getString(nodeToCompare, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
      return true;
    }
    for (final EStructuralFeature structuralFeature : ListSequence.fromList(eClassifier.getEStructuralFeatures())) {
      {
        isMatch.value = false;
        String[] eClassSplit = structuralFeature.getEClass().split("//");
        String[] eTypeClassSplit = structuralFeature.getEType().getEClass().split("//");
        String[] eTypeRefSplit = structuralFeature.getEType().get$ref().split("//");

        String eClass = eClassSplit[eClassSplit.length - 1];
        final Wrappers._T<String> eTypeRef = new Wrappers._T<String>(eTypeRefSplit[eTypeRefSplit.length - 1]);
        String eTypeClass = eTypeClassSplit[eTypeClassSplit.length - 1];
        if (eClass.equals("EAttribute")) {
          eTypeRef.value = this.emfToMpsProperties.get(eTypeRef.value);
          ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.propertyDeclaration$YUgg)).visitAll(new IVisitor<SNode>() {
            public void visit(SNode property) {
              // Depreciated properties in this model are not used.
              if ((boolean) IDeprecatable__BehaviorDescriptor.isDeprecated_idhOwoPtR.invoke(property)) {
                isMatch.value = true;
              } else if (SPropertyOperations.getString(property, PROPS.name$MnvL).toLowerCase().equals(structuralFeature.getName().toLowerCase()) && String.valueOf(SLinkOperations.getTarget(property, LINKS.dataType$5j5Y)).toLowerCase().equals(eTypeRef.value.toLowerCase())) {
                isMatch.value = true;
              }
            }
          });
        } else if (eClass.equals("EReference")) {
          if (eTypeClass.equals("EClass")) {
            for (SNode concept : SetSequence.fromSet(getAllConcepts(this.structuralElements))) {
              if (SPropertyOperations.getString(concept, PROPS.name$MnvL).equals(eTypeRef.value)) {
                isMatch.value = true;
                LoggingRuntime.logMsgView(Level.INFO, "Match found for " + SPropertyOperations.getString(concept, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
              }
            }
          } else {
            for (SNode linkDeclaration : ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.linkDeclaration$YU1f))) {
              if (SPropertyOperations.getString(SLinkOperations.getTarget(linkDeclaration, LINKS.target$m40F), PROPS.name$MnvL).equals(eTypeRef.value)) {
                LoggingRuntime.logMsgView(Level.INFO, "Match found for " + SPropertyOperations.getString(SLinkOperations.getTarget(linkDeclaration, LINKS.target$m40F), PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
                isMatch.value = true;
              }
              LoggingRuntime.logMsgView(Level.INFO, "Comparing for " + SPropertyOperations.getString(SLinkOperations.getTarget(linkDeclaration, LINKS.target$m40F), PROPS.name$MnvL) + " and " + eTypeRef.value, PerformEcoreValidation.class, null, null);
            }
          }
          if (structuralFeature.getLowerBound().isPresent() || structuralFeature.getUpperBound().isPresent()) {
            isCorrectMulticiplicity = isCorrectMultiplicity(structuralFeature, nodeToCompare);
            isMatch.value = isCorrectMulticiplicity;
            LoggingRuntime.logMsgView(Level.INFO, "Multiciplicity for " + structuralFeature.getName() + " = " + isCorrectMulticiplicity, PerformEcoreValidation.class, null, null);
          }
        }
        if (!(isMatch.value)) {
          if (isCorrectMulticiplicity == null) {
            LoggingRuntime.logMsgView(Level.INFO, "No comparison for multiciplicity made for " + structuralFeature.getName(), PerformEcoreValidation.class, null, null);
          }
          LoggingRuntime.logMsgView(Level.INFO, "Inconsistencies found for " + structuralFeature.getName(), PerformEcoreValidation.class, null, null);
          return false;
        }
      }
    }
    return isMatch.value;
  }

  private boolean isCorrectMultiplicity(final EStructuralFeature structuralFeature, SNode nodeToCompare) {
    final Wrappers._boolean isCorrect = new Wrappers._boolean(false);
    // TODO: Check for upper and lower bounds to confirm
    LoggingRuntime.logMsgView(Level.INFO, "Comparing for " + structuralFeature.getName(), PerformEcoreValidation.class, null, null);
    Optional<Integer> upperBound = structuralFeature.getUpperBound();
    Optional<Integer> lowerBound = structuralFeature.getLowerBound();
    boolean containment = structuralFeature.isContainment();
    if (containment) {
      if (upperBound.isPresent()) {
        // missing use case for lowerbound is also present
        if (upperBound.get() == -1) {
          // is a list
          LoggingRuntime.logMsgView(Level.INFO, "Detected unbounded contained list for " + structuralFeature.getName(), PerformEcoreValidation.class, null, null);
          ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getAggregationLinkDeclarations_idhEwILLp.invoke(nodeToCompare)).visitAll(new IVisitor<SNode>() {
            public void visit(SNode aggregLink) {
              if (SPropertyOperations.getString(aggregLink, PROPS.name$MnvL).equals(structuralFeature.getName())) {
                LoggingRuntime.logMsgView(Level.INFO, "Found " + SPropertyOperations.getString(aggregLink, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
                LoggingRuntime.logMsgView(Level.INFO, "Cardinality " + SEnumOperations.getMemberName0(SPropertyOperations.getEnum(aggregLink, PROPS.sourceCardinality$cxYK)), PerformEcoreValidation.class, null, null);
                isCorrect.value = true;
              }
            }
          });
        }
      } else if (lowerBound.isPresent()) {
        // missing use case where upperbound is also present
        if (lowerBound.get() == 1) {
          LoggingRuntime.logMsgView(Level.INFO, "Detected atomic containment for " + structuralFeature.getName(), PerformEcoreValidation.class, null, null);
          ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getAggregationLinkDeclarations_idhEwILLp.invoke(nodeToCompare)).visitAll(new IVisitor<SNode>() {
            public void visit(SNode aggregLink) {
              if (SPropertyOperations.getString(aggregLink, PROPS.name$MnvL).equals(structuralFeature.getName())) {
                LoggingRuntime.logMsgView(Level.INFO, "Found " + SPropertyOperations.getString(aggregLink, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
                LoggingRuntime.logMsgView(Level.INFO, "Cardinality " + SEnumOperations.getMemberName0(SPropertyOperations.getEnum(aggregLink, PROPS.sourceCardinality$cxYK)), PerformEcoreValidation.class, null, null);
                isCorrect.value = true;
              }
            }
          });
        }
      }
    } else {
      if (upperBound.isPresent()) {
        // missing use case for lowerbound is also present
        if (upperBound.get() == -1) {
          // is a list
          LoggingRuntime.logMsgView(Level.INFO, "Detected unbounded reference list for " + structuralFeature.getName(), PerformEcoreValidation.class, null, null);
          ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getReferenceLinkDeclarations_idhEwILL0.invoke(nodeToCompare)).visitAll(new IVisitor<SNode>() {
            public void visit(SNode aggregLink) {
              if (SPropertyOperations.getString(aggregLink, PROPS.name$MnvL).equals(structuralFeature.getName())) {
                LoggingRuntime.logMsgView(Level.INFO, "Found " + SPropertyOperations.getString(aggregLink, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
                LoggingRuntime.logMsgView(Level.INFO, "Cardinality " + SEnumOperations.getMemberName0(SPropertyOperations.getEnum(aggregLink, PROPS.sourceCardinality$cxYK)), PerformEcoreValidation.class, null, null);
                isCorrect.value = true;
              }
            }
          });
        }
      } else if (lowerBound.isPresent()) {
        // missing use case where upperbound is also present
        if (lowerBound.get() == 1) {
          LoggingRuntime.logMsgView(Level.INFO, "Detected atomic reference for " + structuralFeature.getName(), PerformEcoreValidation.class, null, null);
          ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getReferenceLinkDeclarations_idhEwILL0.invoke(nodeToCompare)).visitAll(new IVisitor<SNode>() {
            public void visit(SNode refLink) {
              if (SPropertyOperations.getString(refLink, PROPS.name$MnvL).equals(structuralFeature.getName())) {
                LoggingRuntime.logMsgView(Level.INFO, "Found " + SPropertyOperations.getString(refLink, PROPS.name$MnvL), PerformEcoreValidation.class, null, null);
                LoggingRuntime.logMsgView(Level.INFO, "Cardinality " + SEnumOperations.getMemberName0(SPropertyOperations.getEnum(refLink, PROPS.sourceCardinality$cxYK)), PerformEcoreValidation.class, null, null);
                isCorrect.value = true;
              }
            }
          });
        }
      }
    }
    if (!(isCorrect.value)) {
      LoggingRuntime.logMsgView(Level.INFO, "Incorrect source cardinality for " + structuralFeature.getName(), PerformEcoreValidation.class, null, null);
    }
    return isCorrect.value;
  }


  private Set<SNode> getAllConcepts(List<SNode> rootsIncludingImported) {
    final Set<SNode> allConcepts = SetSequence.fromSet(new HashSet<SNode>());
    ListSequence.fromList(rootsIncludingImported).visitAll(new IVisitor<SNode>() {
      public void visit(SNode root) {
        Sequence.fromIterable(AbstractConceptDeclaration__BehaviorDescriptor.getAllSuperConcepts_id2A8AB0rAWpG.invoke(SNodeOperations.cast(root, CONCEPTS.AbstractConceptDeclaration$KA), ((boolean) true))).visitAll(new IVisitor<SNode>() {
          public void visit(SNode node) {
            SetSequence.fromSet(allConcepts).addElement(node);
          }
        });
      }
    });
    return allConcepts;
  }

  private void populateEmfToMpsTerms() {
    this.emfToMpsConceptTerms.put("NamedElement", "INamedConcept");
    this.emfToMpsProperties.put("EString", "String");
  }

  public Map<EClassifier, SNode> getEcoreToMPS() {
    return new HashMap<EClassifier, SNode>(this.ecoreToMPS);
  }

  public EClassifier eClassifier(String eClassifierName) {
    for (EClassifier eClassifier : SetSequence.fromSet(this.ecoreToMPS.keySet())) {
      if (eClassifier.getName().equals(eClassifierName)) {
        return eClassifier;
      }
    }
    return null;
  }

  public SNode getNode(String eClassifierName) {
    for (SNode node : CollectionSequence.fromCollection(this.ecoreToMPS.values())) {
      if (SPropertyOperations.getString(node, PROPS.name$MnvL).equals(eClassifierName)) {
        return node;
      }
    }
    return null;
  }

  public void stop() {
    this.ecoreToMPS = new HashMap<>();
    this.emfToMpsConceptTerms = new HashMap<>();
    this.emfToMpsProperties = new HashMap<>();
    this.structuralElements = new ArrayList<SNode>();
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
    /*package*/ static final SProperty sourceCardinality$cxYK = MetaAdapterFactory.getProperty(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98054bb04L, "sourceCardinality");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbstractConceptDeclaration$KA = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink linkDeclaration$YU1f = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, "linkDeclaration");
    /*package*/ static final SContainmentLink propertyDeclaration$YUgg = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, "propertyDeclaration");
    /*package*/ static final SReferenceLink dataType$5j5Y = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, 0xfc26f42fe5L, "dataType");
    /*package*/ static final SReferenceLink target$m40F = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98055fef0L, "target");
  }
}
