package MPSListener.plugin.synchronise.validation;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import MPSListener.plugin.synchronise.MPS_LocalRepo;
import com.fasterxml.jackson.databind.ObjectMapper;
import MPSListener.plugin.dataClasses.emf.ecore.Ecore;
import java.util.Map;
import MPSListener.plugin.dataClasses.emf.ecore.EClassifier;
import org.jetbrains.mps.openapi.model.SNode;
import com.fasterxml.jackson.databind.MapperFeature;
import java.util.HashMap;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import java.io.IOException;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import java.util.ArrayList;
import java.util.Set;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import jetbrains.mps.internal.collections.runtime.IVisitor;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.structure.behavior.AbstractConceptDeclaration__BehaviorDescriptor;
import MPSListener.plugin.dataClasses.emf.ecore.ESuperType;
import jetbrains.mps.internal.collections.runtime.Sequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import MPSListener.plugin.dataClasses.emf.ecore.EStructuralFeature;
import jetbrains.mps.lang.core.behavior.IDeprecatable__BehaviorDescriptor;
import java.util.Optional;
import java.util.HashSet;
import jetbrains.mps.internal.collections.runtime.CollectionSequence;
import org.jetbrains.mps.openapi.language.SProperty;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SConcept;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SReferenceLink;

public class PerformEcoreValidation {
  private static final Logger LOG = LogManager.getLogger(PerformEcoreValidation.class);
  private MPS_LocalRepo mpsLocalRepo;
  private String model;
  private String module;
  private java.util.logging.Logger log;
  private ObjectMapper om;

  private Ecore parsedServerSideEcore;
  private Map<EClassifier, SNode> ecoreToMPS;
  private Map<String, String> emfToMpsConceptTerms;
  private Map<String, String> emfToMpsProperties;
  private Iterable<SNode> structuralElements;
  private SNode selectedInstance;

  public PerformEcoreValidation(SNode selectedInstance) {
    // TODO: Move away from parsing using objectMapper to using Document library, used in ContentSynchroniser.
    this.mpsLocalRepo = MPS_LocalRepo.getInstance();
    // hard coded the model to look for.
    this.module = "StateMachines";
    this.model = "structure";
    this.selectedInstance = selectedInstance;
    this.log = java.util.logging.Logger.getLogger(PerformEcoreValidation.class.getSimpleName());
    this.om = new ObjectMapper();
    om.configure(MapperFeature.ACCEPT_CASE_INSENSITIVE_PROPERTIES, true);
    this.ecoreToMPS = new HashMap<>();
    this.emfToMpsConceptTerms = new HashMap<>();
    this.emfToMpsProperties = new HashMap<>();
  }


  public boolean ecoreIsMatchLocally(String eCoreString) {
    LoggingRuntime.logMsgView(Level.INFO, "Performing structural validation for this model's meta model.", PerformEcoreValidation.class, null, null);
    try {
      // Parse the received string 
      this.parsedServerSideEcore = this.om.readValue(eCoreString, Ecore.class);
    } catch (IOException e) {
      log.info(e.getMessage());
    }
    populateEmfToMpsTerms();
    boolean isMatch = false;

    // Fetch the meta-model of the selected model.
    SModel structuralModel = this.mpsLocalRepo.findModel(this.module, this.model);
    this.structuralElements = SModelOperations.roots(structuralModel, null);
    ArrayList<EClassifier> eClassifiers = parsedServerSideEcore.getData().getEClassifiers();

    // Ensure all EClasses are present
    if (allEClassesPresentInMPS(eClassifiers, structuralElements)) {
      eClassifiers.forEach((EClassifier eClassifier) -> {
        {
          // Validate inheritance relationship
          SNode structuralNode = PerformEcoreValidation.this.ecoreToMPS.get(eClassifier);
          if (isMatchSuperType(eClassifier, structuralNode)) {
            // Validate references and attributes, as well multiplicities for each of them, if any.
            isMatchStructuralFeatures(eClassifier, structuralNode);
          }
        }
      });
    } else {
      LoggingRuntime.logMsgView(Level.INFO, "Mismatched ecore, all elements not present by name, discontinuing comparisons", PerformEcoreValidation.class, null, null);
    }
    LoggingRuntime.logMsgView(Level.INFO, "Validation complete", PerformEcoreValidation.class, null, null);
    return isMatch;
  }


  private boolean allEClassesPresentInMPS(ArrayList<EClassifier> eClassifiers, Iterable<SNode> structuralElements) {
    // This method ensures that all eClassifiers from the eCore file are present in the structure. This method does not ensure all mps structural nodes are present in the ecore file. However, that should be done.
    // TODO: Method seems fishy, might not be checking if all eClasses are present, double check
    final Set<SNode> allStructuralNodes = getAllConcepts(structuralElements);
    final Wrappers._boolean elementPresent = new Wrappers._boolean();
    eClassifiers.forEach((final EClassifier eClassifier) -> {
      {
        elementPresent.value = false;
        final String eClassNameToCompare = (PerformEcoreValidation.this.emfToMpsConceptTerms.containsKey(eClassifier.getName()) ? PerformEcoreValidation.this.emfToMpsConceptTerms.get(eClassifier.getName()) : eClassifier.getName());
        SetSequence.fromSet(allStructuralNodes).visitAll(new IVisitor<SNode>() {
          public void visit(SNode structuralNode) {
            if (eClassNameToCompare.equals(SPropertyOperations.getString(structuralNode, PROPS.name$MnvL))) {
              elementPresent.value = true;
              PerformEcoreValidation.this.ecoreToMPS.put(eClassifier, SNodeOperations.cast(structuralNode, CONCEPTS.AbstractConceptDeclaration$KA));
            }
          }
        });
        if (!(elementPresent.value)) {
          return;
        }
      }
    });
    return elementPresent.value;
  }


  private boolean isMatchSuperType(EClassifier eClassifier, SNode nodeToCompare) {
    boolean isMatch = false;
    // This if statement is a bit misleading, nonetheless it checks wether the given eClassifier and MPS node have no supertypes or or if they do, then they are the same.
    if (eClassifier.getESuperTypes() == null && ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getImmediateSuperconcepts_idhMuxyK2.invoke(nodeToCompare)).count() == 0) {
      return true;
    }
    try {

      for (ESuperType superConceptEcore : ListSequence.fromList(eClassifier.getESuperTypes())) {
        {
          String eCoreSuperType = superConceptEcore.get$ref().split("//")[1];

          // Some native terms of emf differ than that of mps, look at the populateEmfToMpsTerms for the current list. Since they can be different, I noted the ones I observed and replace eCoreSuperType with that of MPS.
          eCoreSuperType = ((this.emfToMpsConceptTerms.containsKey(eCoreSuperType)) ? this.emfToMpsConceptTerms.get(eCoreSuperType) : eCoreSuperType);
          for (SNode superType : Sequence.fromIterable(AbstractConceptDeclaration__BehaviorDescriptor.getAllSuperConcepts_id2A8AB0rAWpG.invoke(nodeToCompare, ((boolean) true)))) {
            if (SPropertyOperations.getString(superType, PROPS.name$MnvL).equals(eCoreSuperType)) {
              isMatch = true;
            }
          }
        }
      }
    } catch (NullPointerException e) {
      log.info(e.getMessage());
    }
    return isMatch;
  }

  private boolean isMatchStructuralFeatures(EClassifier eClassifier, SNode nodeToCompare) {
    // Also compares abstract if present
    boolean isMatch = false;
    if (eClassifier.getEStructuralFeatures() == null && ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.propertyDeclaration$YUgg)).count() == 0 && ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.linkDeclaration$YU1f)).count() == 0) {
      return true;
    }
    for (EStructuralFeature structuralFeature : ListSequence.fromList(eClassifier.getEStructuralFeatures())) {
      {
        isMatch = false;
        String[] eClassSplit = structuralFeature.getEClass().split("//");
        String[] eTypeRefSplit = structuralFeature.getEType().get$ref().split("//");

        String eClass = eClassSplit[eClassSplit.length - 1];
        String eTypeRef = eTypeRefSplit[eTypeRefSplit.length - 1];
        if (eClass.equals("EAttribute")) {
          isMatch = eAttributeIsPresent(eTypeRef, nodeToCompare, structuralFeature);
        } else if (eClass.equals("EReference")) {
          isMatch = eContainmentOrEReferenceIsPresent(eTypeRef, nodeToCompare);
          if (structuralFeature.getLowerBound().isPresent() || structuralFeature.getUpperBound().isPresent()) {
            isMatch = isCorrectMultiplicity(structuralFeature, nodeToCompare);
          }
        }
      }
    }
    return isMatch;
  }

  private boolean eContainmentOrEReferenceIsPresent(String eTypeRef, SNode nodeToCompare) {
    boolean isMatch = false;
    for (SNode linkDeclaration : ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.linkDeclaration$YU1f))) {
      if (SPropertyOperations.getString(SLinkOperations.getTarget(linkDeclaration, LINKS.target$m40F), PROPS.name$MnvL).equals(eTypeRef)) {
        isMatch = true;
        break;
      }
    }

    return isMatch;
  }

  private boolean eAttributeIsPresent(String eTypeRef, SNode nodeToCompare, final EStructuralFeature structuralFeature) {
    final Wrappers._T<String> _eTypeRef = new Wrappers._T<String>(eTypeRef);
    final Wrappers._boolean eAttributeIsPresent = new Wrappers._boolean(false);
    _eTypeRef.value = this.emfToMpsProperties.get(_eTypeRef.value);
    ListSequence.fromList(SLinkOperations.getChildren(nodeToCompare, LINKS.propertyDeclaration$YUgg)).visitAll(new IVisitor<SNode>() {
      public void visit(SNode property) {
        // Depreciated properties in this model are not used.
        if ((boolean) IDeprecatable__BehaviorDescriptor.isDeprecated_idhOwoPtR.invoke(property)) {
          eAttributeIsPresent.value = true;
        } else if (SPropertyOperations.getString(property, PROPS.name$MnvL).toLowerCase().equals(structuralFeature.getName().toLowerCase()) && String.valueOf(SLinkOperations.getTarget(property, LINKS.dataType$5j5Y)).toLowerCase().equals(_eTypeRef.value.toLowerCase())) {
          eAttributeIsPresent.value = true;
        } else {
          eAttributeIsPresent.value = false;
        }
      }
    });
    if (!(eAttributeIsPresent.value)) {
      LoggingRuntime.logMsgView(Level.INFO, "EAttribute for " + structuralFeature.getName() + " not present.", PerformEcoreValidation.class, null, null);
    }
    return eAttributeIsPresent.value;
  }

  private boolean isCorrectMultiplicity(final EStructuralFeature structuralFeature, SNode nodeToCompare) {
    final Wrappers._boolean isCorrect = new Wrappers._boolean(false);
    // TODO: Check if carinalities can be other than -1 or 1. This part is kind of hardcoded for our pet project.
    // TODO: Parse the cardinalities to compare with upper and lower bounds, for now it just structural feature exists.
    Optional<Integer> upperBound = structuralFeature.getUpperBound();
    Optional<Integer> lowerBound = structuralFeature.getLowerBound();
    boolean containment = structuralFeature.isContainment();
    if (containment) {
      ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getAggregationLinkDeclarations_idhEwILLp.invoke(nodeToCompare)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode aggregLink) {
          if (SPropertyOperations.getString(aggregLink, PROPS.name$MnvL).equals(structuralFeature.getName())) {
            isCorrect.value = true;
          }
        }
      });
    } else {
      ListSequence.fromList(AbstractConceptDeclaration__BehaviorDescriptor.getReferenceLinkDeclarations_idhEwILL0.invoke(nodeToCompare)).visitAll(new IVisitor<SNode>() {
        public void visit(SNode aggregLink) {
          if (SPropertyOperations.getString(aggregLink, PROPS.name$MnvL).equals(structuralFeature.getName())) {
            isCorrect.value = true;
          }
        }
      });
    }

    return isCorrect.value;
  }


  private Set<SNode> getAllConcepts(Iterable<SNode> rootsIncludingImported) {
    final Set<SNode> allConcepts = SetSequence.fromSet(new HashSet<SNode>());
    rootsIncludingImported.forEach((SNode root) -> {
      Sequence.fromIterable(AbstractConceptDeclaration__BehaviorDescriptor.getAllSuperConcepts_id2A8AB0rAWpG.invoke(SNodeOperations.cast(root, CONCEPTS.AbstractConceptDeclaration$KA), ((boolean) true))).visitAll(new IVisitor<SNode>() {
        public void visit(SNode node) {
          SetSequence.fromSet(allConcepts).addElement(node);
        }
      });
    });
    return allConcepts;
  }

  private void populateEmfToMpsTerms() {
    this.emfToMpsConceptTerms.put("NamedElement", "INamedConcept");
    this.emfToMpsProperties.put("EString", "String");
  }

  public Map<EClassifier, SNode> getEcoreToMPS() {
    return new HashMap<EClassifier, SNode>(this.ecoreToMPS);
  }

  public EClassifier eClassifier(String eClassifierName) {
    for (EClassifier eClassifier : SetSequence.fromSet(this.ecoreToMPS.keySet())) {
      if (eClassifier.getName().equals(eClassifierName)) {
        return eClassifier;
      }
    }
    return null;
  }

  public SNode getNode(String eClassifierName) {
    for (SNode node : CollectionSequence.fromCollection(this.ecoreToMPS.values())) {
      if (SPropertyOperations.getString(node, PROPS.name$MnvL).equals(eClassifierName)) {
        return node;
      }
    }
    return null;
  }

  public void stop() {
    LoggingRuntime.logMsgView(Level.WARN, "Resetting ECore validator..", PerformEcoreValidation.class, null, null);
    this.ecoreToMPS = new HashMap<>();
    this.emfToMpsConceptTerms = new HashMap<>();
    this.emfToMpsProperties = new HashMap<>();
    this.structuralElements = new ArrayList<SNode>();
  }

  private static final class PROPS {
    /*package*/ static final SProperty name$MnvL = MetaAdapterFactory.getProperty(0xceab519525ea4f22L, 0x9b92103b95ca8c0cL, 0x110396eaaa4L, 0x110396ec041L, "name");
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept AbstractConceptDeclaration$KA = MetaAdapterFactory.getConcept(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, "jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink linkDeclaration$YU1f = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6bL, "linkDeclaration");
    /*package*/ static final SContainmentLink propertyDeclaration$YUgg = MetaAdapterFactory.getContainmentLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0x1103553c5ffL, 0xf979c3ba6cL, "propertyDeclaration");
    /*package*/ static final SReferenceLink target$m40F = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086aL, 0xf98055fef0L, "target");
    /*package*/ static final SReferenceLink dataType$5j5Y = MetaAdapterFactory.getReferenceLink(0xc72da2b97cce4447L, 0x8389f407dc1158b7L, 0xf979bd086bL, 0xfc26f42fe5L, "dataType");
  }
}
