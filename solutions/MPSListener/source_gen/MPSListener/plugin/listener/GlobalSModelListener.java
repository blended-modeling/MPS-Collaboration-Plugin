package MPSListener.plugin.listener;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SModelListener;
import org.jetbrains.mps.openapi.model.SNodeChangeListener;
import org.jetbrains.mps.openapi.module.SRepositoryListener;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.module.SRepository;
import org.jetbrains.mps.openapi.model.SModel;
import org.jetbrains.mps.openapi.module.SModule;
import org.jetbrains.mps.openapi.model.SNode;
import MPSListener.plugin.emfModelServer.Client;
import com.fasterxml.jackson.databind.ObjectMapper;
import jetbrains.mps.project.Project;
import jetbrains.mps.baseLanguage.logging.runtime.model.LoggingRuntime;
import org.apache.log4j.Level;
import java.util.List;
import MPSListener.plugin.dataClasses.emf.patches.Patch;
import MPSListener.plugin.emfModelServer.PatchOperations;
import MPSListener.plugin.dataClasses.emf.patches.Root;
import MPSListener.plugin.dataClasses.emf.patches.Data;
import com.fasterxml.jackson.core.JsonProcessingException;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.mps.openapi.event.SPropertyChangeEvent;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.ArrayList;
import org.jetbrains.mps.openapi.event.SReferenceChangeEvent;
import java.util.LinkedHashMap;
import org.jetbrains.mps.openapi.event.SNodeAddEvent;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.model.SReference;
import jetbrains.mps.internal.collections.runtime.Sequence;
import org.jetbrains.mps.openapi.event.SNodeRemoveEvent;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class GlobalSModelListener implements SModelListener, SNodeChangeListener, SRepositoryListener {
  private static final Logger LOG = LogManager.getLogger(GlobalSModelListener.class);

  protected SRepository instanceRepository;
  protected boolean myActive;

  private SModel instanceModel;
  private SModule instanceModule;
  private SNode rootNode;
  private Client client;

  private static GlobalSModelListener instance;
  private ObjectMapper om;
  private String modelName;

  private GlobalSModelListener() {
    this.om = new ObjectMapper();
  }

  public static GlobalSModelListener getInstance() {
    if (instance == null) {
      instance = new GlobalSModelListener();
    }
    return instance;
  }


  public void start(SNode newInstance, Project project) {
    this.rootNode = newInstance;
    this.client = Client.getInstance();
    this.modelName = newInstance.getName() + "." + newInstance.getConcept().getName().toLowerCase();
    this.instanceModel = newInstance.getModel();
    this.instanceModule = this.instanceModel.getModule();
    this.instanceRepository = this.instanceModule.getRepository();
    switchOnListener();
  }

  public void switchOnListener() {
    instanceRepository.getModelAccess().runReadAction(() -> {
      GlobalSModelListener.this.instanceModel.addModelListener(GlobalSModelListener.this);
      GlobalSModelListener.this.instanceModel.addChangeListener(GlobalSModelListener.this);
      GlobalSModelListener.this.instanceRepository.addRepositoryListener(GlobalSModelListener.this);
      LoggingRuntime.logMsgView(Level.WARN, "Activating listener...", GlobalSModelListener.class, null, null);
    });
  }

  public void switchOffListener() {
    myActive = false;
    instanceRepository.getModelAccess().runReadAction(() -> {
      GlobalSModelListener.this.instanceModel.removeModelListener(GlobalSModelListener.this);
      GlobalSModelListener.this.instanceModel.removeChangeListener(GlobalSModelListener.this);
      LoggingRuntime.logMsgView(Level.WARN, "Deactivating listener..", GlobalSModelListener.class, null, null);
    });
  }

  private void sendPatch(List<Patch> patchList) {
    try {
      PatchOperations.getInstance().setIgnorePatch(true);
      this.client.patchModel(this.modelName, om.writeValueAsString(new Root(new Data("modelserver.patch", patchList))));
    } catch (JsonProcessingException e) {
      if (LOG.isInfoEnabled()) {
        LOG.info(e.getMessage());
      }
    }
  }

  public void stop() {
    switchOffListener();
  }

  @Override
  public void modelLoaded(SModel model, boolean partially) {
    if (LOG.isInfoEnabled()) {
      LOG.info(model.getName() + "loaded. Partial load:" + partially);
    }
  }
  @Override
  public void modelReplaced(SModel model) {
  }
  @Override
  public void modelUnloaded(SModel model) {
  }
  @Override
  public void modelSaved(SModel model) {
  }

  @Override
  public void modelAttached(SModel model, SRepository repository) {
  }
  @Override
  public void modelDetached(SModel model, SRepository repository) {
  }
  @Override
  public void conflictDetected(SModel model) {
  }
  @Override
  public void problemsDetected(SModel model, Iterable<SModel.Problem> iterable) {
  }

  @Override
  public void propertyChanged(@NotNull SPropertyChangeEvent event) {
    LoggingRuntime.logMsgView(Level.INFO, "Property changed: for " + event.getNode().getConcept().getName() + " from " + event.getOldValue() + " to " + event.getNewValue(), GlobalSModelListener.class, null, null);
    String path = event.getNode().getContainmentLink().getName() + "/" + SNodeOperations.getIndexInParent(((SNode) event.getNode())) + "/" + event.getProperty().getName();
    List<Patch> patchList = new ArrayList<>();
    patchList.add(new Patch("replace", path, null, event.getNewValue()));

    sendPatch(patchList);

  }
  @Override
  public void referenceChanged(@NotNull SReferenceChangeEvent event) {
    LoggingRuntime.logMsgView(Level.INFO, "Reference change detected..", GlobalSModelListener.class, null, null);
    if (event.getNewValue().getSourceNode() == null) {
      return;
    }

    String path = event.getNewValue().getSourceNode().getContainmentLink().getName() + "/" + SNodeOperations.getIndexInParent(((SNode) event.getNode())) + "/" + event.getAssociationLink().getName();

    LinkedHashMap<String, String> values = new LinkedHashMap<>();
    values.put("$ref", this.rootNode.getName() + "." + this.rootNode.getConcept().getName().toLowerCase() + "#//" + "@" + event.getNewValue().getTargetNode().getContainmentLink().getName() + "." + SNodeOperations.getIndexInParent(((SNode) event.getNewValue().getTargetNode())));

    List<Patch> patchList = new ArrayList<>();
    patchList.add(new Patch("replace", path, null, values));

    sendPatch(patchList);
  }


  @Override
  public void nodeAdded(@NotNull final SNodeAddEvent event) {
    // TODO:Check for existing properties to report to the server and move away from hardcoding type value
    SNode addedNode = event.getChild();
    String indexToReport = (PatchOperations.getInstance().getLastIndexByConcept(event.getChild().getConcept().getName()) == SNodeOperations.getIndexInParent(addedNode) - 1 ? "-" : String.valueOf(SNodeOperations.getIndexInParent(addedNode)));
    String path = event.getAggregationLink().getName() + "/" + indexToReport;

    final LinkedHashMap<String, Object> values = new LinkedHashMap<>();
    // FIXME: Hardcoded the nsURI below, get it from the dataclass
    values.put("$type", "http://nl.vu.cs.bumble/statemachine#//" + event.getChild().getConcept().getName());

    if (event.getChild().getProperties().spliterator().getExactSizeIfKnown() > 0) {
      event.getChild().getProperties().forEach((SProperty currentProperty) -> values.put(currentProperty.getName(), event.getChild().getProperty(currentProperty)));
    }
    if (event.getChild().getReferences().spliterator().getExactSizeIfKnown() > 0) {
      for (SReference currentReference : Sequence.fromIterable(event.getChild().getReferences())) {
        LinkedHashMap<String, String> referenceDetails = new LinkedHashMap<>();
        referenceDetails.put("$type", "http://nl.vu.cs.bumble/statemachine#//" + currentReference.getTargetNode().getConcept().getName());
        referenceDetails.put("$ref", this.rootNode.getName() + "." + this.rootNode.getConcept().getName().toLowerCase() + "#//" + "@" + currentReference.getTargetNode().getContainmentLink().getName() + "." + SNodeOperations.getIndexInParent(((SNode) currentReference.getTargetNode())));
        values.put(currentReference.getLink().getName(), referenceDetails);
      }
    }

    List<Patch> patchList = new ArrayList<>();
    patchList.add(new Patch("add", path, null, values));

    PatchOperations.getInstance().updateStructuralMap(event.getChild(), SNodeOperations.getIndexInParent(addedNode), Integer.MAX_VALUE, "+");
    sendPatch(patchList);
    LoggingRuntime.logMsgView(Level.INFO, "Node addition detected", GlobalSModelListener.class, null, null);

  }
  @Override
  public void nodeRemoved(@NotNull final SNodeRemoveEvent event) {
    LoggingRuntime.logMsgView(Level.INFO, "Node removal detected.", GlobalSModelListener.class, null, null);
    // Nodes that are removed have a null containment link, so need to find that again to notify the server.
    final Wrappers._T<SContainmentLink> containmentLinkOfRemovedNode = new Wrappers._T<SContainmentLink>(null);
    event.getParent().getConcept().getContainmentLinks().forEach((SContainmentLink containmentLink) -> {
      if (containmentLink.getTargetConcept().getName().equals(event.getChild().getConcept().getName())) {
        containmentLinkOfRemovedNode.value = containmentLink;
      }
    });
    String path = containmentLinkOfRemovedNode.value.getName();
    Integer lastIndexByConcept = PatchOperations.getInstance().getLastIndexByConcept(event.getChild().getConcept().getName());
    path = (lastIndexByConcept == 0 ? path : path + "/" + String.valueOf(lastIndexByConcept));

    // Read me: So in order to remove input, one has to do input/[index]/name. But if i want to remove transition, I can do transition/[index]. So you notice I HAVE to mention a property for input, but not for removing transition. So my guess is nodes which only have one property and no other references, you have to include that in the path for removing the node, so for input: input/[index]/name, but for those which have property(s) and reference links, you can just remove them by their name and index.
    final Wrappers._int numOfProperties = new Wrappers._int(0);
    event.getChild().getProperties().forEach((SProperty property) -> numOfProperties.value += 1);
    if (numOfProperties.value >= 1) {
      SProperty property = event.getChild().getProperties().iterator().next();
      path += "/" + property.getName();
    }

    PatchOperations.getInstance().updateStructuralMap(event.getChild(), SNodeOperations.getIndexInParent(((SNode) event.getChild())), Integer.MAX_VALUE, "-");

    List<Patch> patchList = new ArrayList<>();
    patchList.add(new Patch("remove", path, null, null));

    sendPatch(patchList);
  }

  public SRepository getRepositary() {
    return this.instanceRepository;
  }
  public SModule getModule() {
    return this.instanceModule;
  }
}
